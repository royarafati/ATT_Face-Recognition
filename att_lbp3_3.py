# -*- coding: utf-8 -*-
"""ATT_LBP3*3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v50heFFAMGcgdm2cFxkY-xjjVUwv_4Xo
"""

from os.path import join
from google.colab import drive

ROOT = "/content/drive"
drive.mount(ROOT)

import numpy as np
import cv2
import re
import glob
from skimage.feature import local_binary_pattern
from sklearn.metrics import confusion_matrix,ConfusionMatrixDisplay
import matplotlib.pyplot as plt
from sklearn.metrics import plot_confusion_matrix
import itertools

"""Defining LBP Histogram """

def lbp_histogram(color_image):
  width , height ,_ = color_image.shape
  total_img = []
  total_hist = []
  im1 = color_image[0:int(width/3) , 0:int(height/3)]
  total_img.append(im1)
  im2 = color_image[int(width/3):int(2*width/3) , 0:int(height/3)]
  total_img.append(im2)
  im3 = color_image[int(2*width/3):width , 0:int(height/3)]
  total_img.append(im3)
  im4 = color_image[0:int(width/3) , int(height/3):int(2*height/3)] 
  total_img.append(im4) 
  im5 = color_image[int(width/3):int(2*width/3) , int(height/3):int(2*height/3)]
  total_img.append(im5)
  im6 = color_image[int(2*width/3):width , int(height/3):int(2*height/3)]
  total_img.append(im6)
  im7 = color_image[0:int(width/3) , int(2*height/3):height]  
  total_img.append(im7)
  im8 = color_image[int(width/3):int(2*width/3) , int(2*height/3):height]
  total_img.append(im8)
  im9 = color_image[int(2*width/3):width , int(2*height/3):height]
  total_img.append(im9)

  A=[]
  for i in range(9):
    img = cv2.cvtColor(total_img[i], cv2.COLOR_BGR2GRAY)
    patterns = local_binary_pattern(img, 8, 1)
    n = int(patterns.max())
    hist, _ = np.histogram(patterns, bins=n, range=(0, n), density=True)
    A = np.concatenate((A , hist),axis =None)
    #print(hist)
  total_hist.append(A)
  return total_hist

"""Defining Test & Train Set :"""

train = []
for i in glob.glob('/content/drive/MyDrive/att_faces/**/*[1-8].pgm'):
  DB_Image_train = cv2.imread(i)
  train.append([DB_Image_train,f'{i}'])

test = []
for i in glob.glob('/content/drive/MyDrive/att_faces/**/*[9,0].pgm'):
  DB_Image_test = cv2.imread(i)
  test.append([DB_Image_test,f'{i}'])

"""Database LBP Histogram"""

train_Hist=[]
for i in range(len(train)):
    DB_Image = train[i][0]
    DB_Hist = lbp_histogram(DB_Image)
    train_Hist.append([DB_Hist,f'{train[i][1]}']) # train.shape(320*2*9)

"""Test"""

total_compare=[]
for j in range(len(test)):
  query_image = test[j][0]
  query_feature = lbp_histogram(query_image)
  total_score = []
  for l in range(len(train_Hist)):
    Score = cv2.compareHist(np.float32(train_Hist[l][0]),np.float32(query_feature), cv2.HISTCMP_CHISQR)
    total_score.append([Score,train_Hist[l][1]])
  total_score.sort()
  total_compare.append(total_score)

"""Confusion Matrix & Accuracy"""

count=0
y_actu = []
y_pred = []
for i in range(len(test)):
  temp = re.findall(r'\d+', test[i][1])
  Img_number = list(map(int, temp)) #Img_number[folder,Image_name]
  DB_str = total_compare[i][0][1]
  DB_temp = re.findall(r'\d+', DB_str)
  DB_number = list(map(int, DB_temp)) #DB_number[folder,Image_name]
  if Img_number[0]==DB_number[0]:
    count+=1
  y_actu.append(Img_number[0])
  y_pred.append(DB_number[0])

total_accuracy = ((count)/80)            
print("Total Accuracy is "+ str(total_accuracy))

def plot_confusion_matrix(cm, classes,
                          normalize=False,
                          title='Confusion matrix',
                          cmap=plt.cm.Blues):
    """
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    """
    import itertools
    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
        print("Normalized confusion matrix")
    else:
        print('Confusion matrix, without normalization')

    print(cm)

    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)
    fmt = '.2f' if normalize else 'd'
    thresh = cm.max() / 2.
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, format(cm[i, j], fmt),
                 horizontalalignment="center",
                 color="white" if cm[i, j] > thresh else "black")

    plt.ylabel('True label')
    plt.xlabel('Predicted label')
    plt.tight_layout()

cnf_matrix = confusion_matrix(y_actu, y_pred,labels=range(1,41))
np.set_printoptions(precision=2)

# Plot non-normalized confusion matrix
plt.figure(figsize=(20,10))
plot_confusion_matrix(cnf_matrix, classes=range(1,41),
                      title='Confusion matrix, without normalization')